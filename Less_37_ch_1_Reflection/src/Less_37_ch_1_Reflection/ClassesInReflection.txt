******* Classes - Классы *******

Каждый тип данных в Java является либо ссылкой, либо примитивом. Классы,
перечисления и массивы (все они наследуются от java.lang.Object), а также
интерфейсы — все это ссылочные типы. Примеры ссылочных типов включают
java.lang.String все классы-оболочки для примитивных типов, таких как
java.lang.Double интерфейс java.io.Serializable и перечисление
javax.swing.SortOrder.

Существует фиксированный набор примитивных типов: boolean, byte, short, int,
long, char, float, и double.

Для каждого типа объекта виртуальная машина Java создает неизменяемый экземпляр,
java.lang.Class, который предоставляет методы для проверки свойств объекта во
время выполнения, включая его элементы и информацию о типе. Class также
предоставляет возможность создавать новые классы и объекты. Самое главное, это
точка входа для всех API-интерфейсов Reflection.

******* Получение объектов класса *******

Точкой входа для всех операций рефлексии является java.lang.Class. За исключением
java.lang.reflect.ReflectPermission, ни один из классов в java.lang.reflect не имеет
общедоступных конструкторов. Чтобы добраться до этих классов, необходимо вызвать
соответствующие методы в Class.

Существует несколько способов получить Class в зависимости от того, имеет ли код доступ
к объекту, имени класса, типу или существующему файлу Class.

Если экземпляр объекта доступен, то самый простой способ получить
его Class - вызвать Object.getClass(). Конечно, это работает только
для ссылочных типов, которые наследуются от Object.
Ниже приведены некоторые примеры.
----------------------------------------------------------------------------
Возвращает Class для String:

Class c = "foo".getClass();
----------------------------------------------------------------------------

----------------------------------------------------------------------------
Существует уникальная консоль, связанная с виртуальной машиной, которая
возвращается static методом System.console(). Возвращаемое getClass()
значение Class соответствует java.io.Console.

Class c = System.console().getClass();
----------------------------------------------------------------------------

----------------------------------------------------------------------------
A - является экземпляром перечисления E; таким образом getClass() возвращает
Class соответствующий типу перечисления E.

enum E { A, B }
Class c = A.getClass();
----------------------------------------------------------------------------

----------------------------------------------------------------------------
Поскольку массивы - это тоже Objects, то значит можно вызывать getClass()
экземпляр этого массива. Возвращаемое значение Class соответствует массиву
с типом компонента 'byte'.

byte[] bytes = new byte[1024];
Class c = bytes.getClass();
----------------------------------------------------------------------------

----------------------------------------------------------------------------
В данном случае java.util.Set это интерфейс к объекту типа java.util.HashSet.
Возвращаемое значение getClass() - это класс, соответствующий java.util.HashSet.

import java.util.HashSet;
import java.util.Set;

Set<String> s = new HashSet<String>();
Class c = s.getClass();
----------------------------------------------------------------------------

******* Синтаксис *.class *******

Если тип доступен, но экземпляра нет, то можно получить Class, добавив ".class"
к имени типа. Это также самый простой способ получить Class примитивного типа.

Нужно помнить, что метод boolean.getClass() вызовет ошибку времени компиляции,
поскольку a boolean является примитивным типом и не может быть разыменована.
Синтаксис *.class возвращает Class соответствующий типу boolean.
----------------------------------------------------------------------------
boolean b;
Class c = b.getClass();   // compile-time ERROR

Class c = boolean.class;  // CORRECT
----------------------------------------------------------------------------

В данном варианте, переменная 'c' будет  соответствовать Class типу java.io.PrintStream.
----------------------------------------------------------------------------
Class c = java.io.PrintStream.class;
----------------------------------------------------------------------------

Синтаксис *.class может использоваться для извлечения Class соответствующего многомерного
массива заданного типа.
----------------------------------------------------------------------------
Class c = int[][][].class;
----------------------------------------------------------------------------

******* Class.forName() *******

Если доступно полное имя класса, можно получить соответствующее Class с помощью статического
метода Class.forName(). Это нельзя использовать для примитивных типов. Синтаксис имен классов
массивов описан в Class.getName(). Данный синтаксис применим к ссылкам и примитивным типам.

Этот оператор создаст класс из заданного полного имени.
----------------------------------------------------------------------------
Class c = Class.forName("com.duke.MyLocaleServiceProvider");
----------------------------------------------------------------------------

Переменная cDoubleArray будет содержать Class соответствующий массиву примитивного
типа double (то есть такой же, как double[].class). Переменная cStringArray будет
содержать Class соответствующий двумерному массиву String (то есть идентичный
String[][].class).
----------------------------------------------------------------------------
Class cDoubleArray = Class.forName("[D");

Class cStringArray = Class.forName("[[Ljava.lang.String;");
----------------------------------------------------------------------------

******* Поле TYPE для обёрток примитивного типа *******

Синтаксис *.class является более удобным и предпочтительным способом получения Class
примитивного типа, однако есть еще один способ получить Class. Каждый из примитивных
типов имеет void класс-оболочку java.lang, который используется для упаковки примитивных
типов в ссылочные типы. Каждый класс-оболочка содержит поле с именем TYPE, которое
равно Class для обертываемого примитивного типа.

Существует класс java.lang.Double, который используется для переноса примитивного типа
double всякий раз, когда требуется Object. Значение Double.TYPE идентично значению double.class.
----------------------------------------------------------------------------
Class c = Double.TYPE;
----------------------------------------------------------------------------

void.TYPE идентичен void.class.
----------------------------------------------------------------------------
Class c = Void.TYPE;
----------------------------------------------------------------------------

******* Методы, возвращающие классы *******

Существует несколько API-интерфейсов Reflection, которые возвращают классы, но к ним
можно получить доступ только в том случае, если Class уже был получен прямо или косвенно.

- Class.getSuperclass() - возвращает суперкласс для данного класса.
Пример:
----------------------------------------------------------------------------
Class c = javax.swing.JButton.class.getSuperclass();
Cуперкласс для javax.swing.JButton это javax.swing.AbstractButton
----------------------------------------------------------------------------

- Class.getClasses() - возвращает все открытые классы, интерфейсы и перечисления, которые
                       являются членами класса (вложенными классами), включая унаследованные
                       члены (классы предков).
Пример:
----------------------------------------------------------------------------
Class<?>[] c = Character.class.getClasses();
Character содержит два вложенных класса Character.Subset и Character.UnicodeBlock.
см. https://docs.oracle.com/javase/7/docs/api/java/lang/Character.html
----------------------------------------------------------------------------

- Class.getDeclaredClasses() - возвращает все интерфейсы классов и перечисления, явно
                               объявленные в текущем классе (методы предков в выдаче не
                               участвуют).
Пример:
----------------------------------------------------------------------------
Class<?>[] c = Character.class.getDeclaredClasses();
Character содержит два вложенных public класса Character.Subset и Character.UnicodeBlock
и один private класс Character.CharacterCache.
----------------------------------------------------------------------------

Пример возвращает, Class в котором элементы были объявлены. Объявления анонимных классов
не будут иметь объявляющего класса, но будут иметь охватывающий класс. Импортировать
java.lang.reflect.Field;
----------------------------------------------------------------------------
Class.getDeclaringClass()
java.lang.reflect.Field.getDeclaringClass()
java.lang.reflect.Method.getDeclaringClass()
java.lang.reflect.Constructor.getDeclaringClass()
----------------------------------------------------------------------------

*.getDeclaringClass() - если класс или интерфейс, представленный этим объектом Class, является
членом другого класса, возвращает объект Class, представляющий класс, в котором он был объявлен.
Этот метод возвращает null, если этот класс или интерфейс не является членом какого-либо другого
класса. Если текущий объект Class представляет класс массива, примитивный тип или пустоту, то
этот метод возвращает значение null.

Метод возвращает: объявляющий класс для этого класса

Пример получения поля с названием 'out' объявлено в классе System.
----------------------------------------------------------------------------
import java.lang.reflect.Field;

Field f = System.class.getField("out");
Class c = f.getDeclaringClass();
----------------------------------------------------------------------------

Класс содержит анонимный класса, определенный с помощью 'o' как null.
----------------------------------------------------------------------------
public class MyClass {
    static Object o = new Object() {
        public void m() {}
    };
    static Class<c> = o.getClass().getEnclosingClass();
}
----------------------------------------------------------------------------

- Class.getEnclosingClass() - возвращает непосредственно охватывающий класс класса.
Пример:
----------------------------------------------------------------------------
Class c = Thread.State.class().getEnclosingClass();
Thread.State охватывающий класс перечисления Thread.
----------------------------------------------------------------------------

Анонимный класс, определенный с помощью o, заключен в MyClass.
----------------------------------------------------------------------------
public class MyClass {
    static Object o = new Object() {
        public void m() {}
    };
    static Class<c> = o.getClass().getEnclosingClass();
}
----------------------------------------------------------------------------

Методы класса Class для поиска полей
----------------------------------------------------------------------------
Class API	        | Список полей | Унаследованные поля | Private поля
----------------------------------------------------------------------------
getDeclaredField()  |     нет      |        нет          |       да
----------------------------------------------------------------------------
getField()          |     нет      |        да           |       нет
----------------------------------------------------------------------------
getDeclaredFields() |     да       |        нет          |       да
----------------------------------------------------------------------------
getFields()         |     да       |        да           |       нет
----------------------------------------------------------------------------

Методы класса Class для поиска методов
---------------------------------------------------------------------------------
Class API             | Список методов | Унаследованные методы | Private методы
---------------------------------------------------------------------------------
 getDeclaredMethod()  |       нет      |          нет          |       да
---------------------------------------------------------------------------------
 getMethod()          |       нет      |          да           |       нет
---------------------------------------------------------------------------------
 getDeclaredMethods() |       да       |          нет          |       да
---------------------------------------------------------------------------------
 getMethods()         |       да       |          да           |       нет
---------------------------------------------------------------------------------

Методы класса Class для поиска конструкторов (Конструкторы не наследуются)
---------------------------------------------------------------------
Class API             | Список конструкторов | Private конструкторы
---------------------------------------------------------------------
 getDeclaredMethod()  |          нет         |       да
---------------------------------------------------------------------
 getMethod()          |          нет         |       нет
---------------------------------------------------------------------
 getDeclaredMethods() |          да          |       да
---------------------------------------------------------------------
 getMethods()         |          да          |       нет
---------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
См. более подробно : https://docs.oracle.com/javase/tutorial/reflect/index.html

