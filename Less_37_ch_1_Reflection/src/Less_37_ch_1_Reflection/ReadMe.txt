******* Reflection API *******

Рефлексия обычно используется программами, которым требуется возможность
исследовать или изменять поведение приложений, работающих на виртуальной
машине Java, во время выполнения. Это относительно продвинутая функция, и
ее должны использовать только разработчики, хорошо разбирающиеся в основах
языка. Учитывая это предостережение, рефлексия является мощной техникой,
позволяющей приложениям выполнять операции, которые в противном случае были
бы невозможны.

Возможности расширения - приложение может использовать внешние пользовательские
классы, создавая экземпляры объектов расширяемости, используя их полные имена.

Браузеры классов и визуальные среды разработки - браузер классов должен иметь
возможность перечислять членов классов. Среды визуальной разработки могут выиграть
от использования информации о типах, доступной при использовании рефлексии, чтобы
помочь разработчику написать правильный код.

Отладчики и инструменты тестирования - отладчики должны иметь возможность проверять
частные члены в классах. Инструментальные средства тестирования могут использовать
рефлексию для систематического вызова API-интерфейсов обнаруживаемого набора,
определенных в классе, чтобы обеспечить высокий уровень покрытия кода в наборе тестов.

Иными словами Рефлексия - это API, который позволяет:
- получать информацию о переменных, методах внутри класса, о самом классе, его конструкторах,
  реализованных интерфейсах и т.д.;
- получать новый экземпляр класса;
- получать доступ ко всем переменным и методам, в том числе приватным;
- преобразовывать классы одного типа в другой (cast);
- делать все это во время исполнения программы (динамически, в Runtime).

******* Недостатки рефлексии *******

Рефлексия мощный инструмент, но его не следует использовать без разбора. Если есть возможность
выполнить операцию без использования рефлексии, то лучше реализовать более безопасный способ
нежели рефлексия. При доступе к коду через классы и методы рефлексии следует помнить о следующих
проблемах.

Накладные расходы на производительность - поскольку рефлексия включает типы, которые разрешаются
динамически, некоторые оптимизации виртуальной машины Java выполнить невозможно. Следовательно,
рефлексивные операции имеют более низкую производительность, чем их нерефлексивные аналоги, и их
следует избегать в разделах кода, которые часто вызываются в приложениях, чувствительных к
производительности.

Ограничения безопасности - для классов и методов рефлексии требуется разрешение времени выполнения,
которое может отсутствовать при работе под управлением менеджера безопасности. Это важно для кода,
который должен выполняться в ограниченном контексте безопасности, например, в апплете.

Воздействие внутренних органов - поскольку рефлексия позволяет коду выполнять операции, которые были
бы недопустимы в нерефлексивном коде, например, доступ к private полям и методам, использование
рефлексии может привести к неожиданным побочным эффектам, которые могут сделать код неработоспособным
и нарушить переносимость.

Рефлексивный код разрушает абстракции и поэтому может изменить поведение при обновлении платформы.

Другими словами:
- Худшая производительность в сравнении с классической работой с классами, методами и переменными;
- Ограничения безопасности. Если мы захотим использовать рефлексию на классе, который защищен с
  помощью специального класса SecurityManager, то ничего не выйдет т.к. этот класс будет выбрасывать
  исключения каждый раз, как мы попытаемся получить доступ к закрытым членам класса. Такая защита
  может применяться, например, в Апплетах (Applets);
- Получение доступа к внутренностям класса, что нарушает принцип инкапсуляции. Фактически, мы получаем
  доступ туда, куда обычному человеку лезть не желательно. Это как с розеткой, ребёнку лучше к ней не
  лезть, тогда как опытный электрик запросто с ней поладит.

-------------------------------------------------------------------------------------------------------
См. более подробно : https://docs.oracle.com/javase/tutorial/reflect/index.html
