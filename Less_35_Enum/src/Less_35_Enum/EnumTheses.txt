******* Enum - тезисы *******

1. Enum - это отдельная структура. Он может находится в отдельном файле, а может быть
   частью класса. Но при этом enum не обязательно должен лежать в каком-либо классе.
   При таком подходе мы как бы создаем еще один класс, только вместо слова "class"
   пишем "enum".

2. У enum-ов есть модификатор доступа. Если Ваш enum не лежит внутри какого-нибудь
   класса, он должен быть объявлен public. Если же enum будет "внутри" класса, он
   может быть объявлен private.

3. Все объекты, которые лежат в enum-е, принято писать большими буквами - это
   общепринятая практика.

4. Объекты, которые лежат в enum-е, пишутся через запятую.
-----------------------------------------------------------------------------------------------
public enum Seasons {
    WINTER,
    SUMMER,
    SPRING,
    FALL;
}
-----------------------------------------------------------------------------------------------

5. Когда мы вызываем объекты из enum-а, мы сначала пишем название самого enum-а,
   а потом через точку - название объекта:
-----------------------------------------------------------------------------------------------
Seasons.WINTER
-----------------------------------------------------------------------------------------------

6 . У enum-ов есть метод - values(). Он возвращает массив значений, которые хранятся
    в данном enum-е. С помощью оператора for each мы можем пройтись по этому массиву
    и вывести его значения.
-----------------------------------------------------------------------------------------------
for (Seasons s : Seasons.values()) {
            System.out.println(s);
        }
-----------------------------------------------------------------------------------------------
(см. пример Less_35_Enum_Step2, в нем данный метод применен на классе Planet)

7. К Enum можно применять методы:
    name() - возвращает имя;
    ordinal() - возвращает порядковый номер;
    equals() - метод equals() сравнивает значения перечислений по ссылкам.
               Т.к. значения в перечислениях являются константными (уникальными),
               существует всего один экземпляр MARS, один SATURN или EARTH, значит
               ссылка на этот экземпляр будет всего одна, и значит их можно
               сравнивать с помощью '==';
    hashCode() - метод hashCode() использует стандартную реализацию из класса Object;
    toString() - метод toString() возвращает имя значения перечисления.
                 Назвали значение MARS, это же значение и получим при
                 вызове toString() или name();
    finalize() - метод finalize() пустой, а это значит, что не нужно закрывать "ресурсы"
                 перед сборщиком мусора. Но только для тех "ресурсов", которые используются
                 в try-with-resources. Метод finalize() в Java 9 уже помечен, как
                 @Deprecated (устаревший метод, не рекомендуемый к применению);
    clone() - метод clone() мы можем вызвать только внутри самого перечисления т.к. он помечен
              ключевым словом protected. Но даже если мы попытаемся сделать это, то ничего мы
              не получим, кроме CloneNotSupportedException;
    values() - позволяет получить массив всех значений Enum;
    valueOf() - позволяет получить значения перечисления по его строковому представлению;

8. Enum реализует интерфейс Comparable - сравнивать перечисления можно только между своими типами,
                                         нельзя сравнивать перечисления типа Color с перечислением
                                         типа Car.
9. Enum реализует интерфейс Serializable - как и в случае с clone() воспользоваться мы им не можем;

